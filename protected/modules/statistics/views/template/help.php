<?php
$this->breadcrumbs=array(
    Yii::t('application', 'Report help'),
);

$this->menu=array(
    array('label'=>Yii::t('application', 'Create template'),'url'=>array('create')),
    array('label'=>Yii::t('application', 'Manage templates'),'url'=>array('admin')),
);

?>
<h1><?=Yii::t('application', 'Report help')?></h1>

<h2>Структура данных</h2>
<p>Структура данных представлена на <a href="/images/db.model.png" target="_blank">схеме</a></p>

<h2>Основные положения</h2>
<p>Принцип построения отчетов опирается на синтаксис sql-запросов. Отличительной чертой являются следующие элементы:</p>
<ul>
    <li>
        Указание параметров для очтета.
        Параметры задаются с помощью специального символа "$" после требуемого название столбца.<br>
        Например: where username$ and created_at$date. Здесь указывается два параметра для фильтрации отчета "username" и "created_at".<br>
        Параметры могут быть разных типов. Тип указывается после символа "$"
        <ul>
            <li>
                текстовый (field$ - если тип не указан, то по умолчанию это text)- поиск по указанному участку текста. В ответе отобразится текстовое поле
            </li>
            <li>
                временной интервал (field$date) - поиска по временному интервалу. В отчете отобразится два поля с выбором дат "с" и "по"
            </li>
            <li>
                список чекбоксов (field$checkboxes{{select id, name from user}}) - поиск по нескольким значениям из списка. Важно: в подзапросе всегда должно быть два поля id и name. Если нужны другие поля то можно использоваться следующий синтаксис: <pre>{{SELECT CONCAT(surname,' ',firstname) as id, surname as name FROM `user`}}</pre>
            </li>
        </ul>
    </li>
    <li>
        Указание типов столбцов.
        Для вычисления последней строки "Итого" можно указывать типы аггрегации данных (указывается через двойное поддчеркивание - "__min"). Если тип столбца не указан, то никакой информации по него в "Итого" не будет.<br>
        Например: SELECT username, call_time AS call_time__avg, call_time AS call_time__max<br>
        В примере из запроса выбираются 3 поля "username" не будет учавстровать в итоговой строке, второе значение выведет в "Итого" среднюю продолжительность звонков,
        а третье значение - максимальную продолжительность. Типы аггрегации данных бывают следующих видов:
        <ul>
            <li>min - минимальное значение</li>
            <li>max - максимальное значение</li>
            <li>avg - среднее значение</li>
            <li>sum - сумма всех значений</li>
        </ul>
    </li>
    <li>
        Отдельным случаем является поле с название filename, в котором хранится адрес до файла на сервер.
        Если в запросе встречается данное поле, то в отчете оно автоматически предложит скачать файл или послушать.
    </li>
</ul>

<h2>Порядок создания отчетов</h2>
<ul>
    <li>
        Проводим анализ того какие данные требуются в отчете, из каких таблиц их следует получить и как эти таблицы связаны между собой
    </li>
    <li>
        Пишем запрос на выборку данных
    </li>
    <li>
        Добавляем в блок WHERE параметры для генерации отчета (полня со служебным символом "$")
    </li>
    <li>
        Указывает какие поля должны попасть в итог отчета с указанием типа аггрегации данных
    </li>
    <li>
        На всех этапах полезно будет периодически проверять, что отчет не содержит ошибок. Для этого достаточно нажать кнопку "Проверить отчет". Сохранять для этого не обязательно
    </li>
    <li>
        Когда шаблон написан, следует еще раз запустить проверку и сохраниться
    </li>
    <li>
        Отчет появится в меню, только если у шаблона указать статус "Опубликован". Примечание: если шаблон содержит ошибки, то опубликовать его не удасться.
    </li>
</ul>

<h2>Пример создания шаблона</h2>
<p>Рассмотрим пример построение шаблона по детальной статистике звонков</p>
<p>Выясняем в каких таблицах у нас хранится необходимая информация:</p>
<ul>
    <li>
        group - здесь хранится перечень служб по которым нам нужно группировать выборку
    </li>
    <li>
        call_log - а непосредственно здесь хранится информация по истории звонков
    </li>
</ul>
<p>Напишем в "Текст шаблона" простой запрос для получения всей информации</p>
<pre>
select *
  from `group` g
  join `call_log` c on c.group_id = g.id
</pre>
<p>
    После нажатия "Проверить отчет" снизу отобразится информация о том сколько строк было получено, и какие стобцы попали в выборку.
    Теперь добавим в отчет группировку по службам:
</p>
<pre>
    select g.name,
       COUNT(c.id) AS call_all,
       SUM(IF(c.status in (1,4), 1, 0)) AS call_ans,
       SEC_TO_TIME(AVG(IF(c.status in (1,4),c.time_ans - c.time_in, null))) AS avg_time_ans_wait,
       ROUND(SUM(IF(c.status in (1,4), 1, 0)) / COUNT(c.id), 2) AS percent_ans
  from `group` g
  join call_log c on c.group_id = g.id
 group by c.group_id
</pre>
<p>
    Здесь мы группирует по службам, выводим ее название и информацию по:
</p>
<ul>
    <li>
        общему кол-ву звонков - COUNT(c.id).
    </li>
    <li>
        кол-ву принятых звонков - SUM(IF(c.status in (1,4), 1, 0)).
        Здесь IF в зависимости от состояния поля c.status возвращает 1 (если статус = 1 или 4) или 0 в противном случае.
        SUM - суммирует то что возвращает IF.
    </li>
    <li>
        среднему времени ожидания перед ответом - SEC_TO_TIME(AVG(IF(c.status in (1,4),c.time_ans - c.time_in, null))).
        Здесь нужно уточнить, что если IF возвращает null, то AVG не учитывает данное значение при подсчете.
        SEC_TO_TIME - конвертирует кол-во секунд, полученно при c.time_ans - c.time_in (время ответа - время поступления звонка) в формат времени.
    </li>
    <li>
        отношению количества ответов к общему кол-ву звонков - ROUND(SUM(IF(c.status in (1,4), 1, 0)) / COUNT(c.id), 2).
        ROUND - округляет полученное значение но 2-х знаков после запятой
    </li>
</ul>
<p>Примечание: все доступные функции стоит искать в документации к MYSQL</p>
<p>
    На данном этапе у нас есть рабочий шаблон для вывода общего списка служб с нужными значениями по звонкам.
    Теперь нам надо сформировать строку "Итого", добавим к названиям полей тип аггрегирующей опперации. Так же добавим в условие два параметра по которым будет формировать отчет.
</p>
<pre>
    select g.name,
       COUNT(c.id) AS call_all__sum,
       SUM(IF(c.status in (1,4), 1, 0)) AS call_ans__sum,
       SEC_TO_TIME(AVG(IF(c.status in (1,4),c.time_ans - c.time_in, null))) AS avg_time_ans_wait_max,
       ROUND(SUM(IF(c.status in (1,4), 1, 0)) / COUNT(c.id), 2) AS percent_ans__avg
  from `group` g
  join call_log c on c.group_id = g.id
 where g.name$ and c.time_in$date
 group by c.group_id
</pre>
<p>
    Теперь можно опубликовать отчет и увидеть что получится
</p>